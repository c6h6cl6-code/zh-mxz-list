name: Disable Interaction of Prohibited Users

on:
  issues:
    types: [opened, reopened]
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, reopened]

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  manage-prohibited-users:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Handle issues, PRs, comments, reopens, and blocklist updates
        uses: actions/github-script@v7
        with:
          script: |
            const getEventActor = () => {
              const { eventName, payload } = context;
              if (eventName === 'issues') return payload.issue.user.login;
              if (eventName === 'issue_comment') return payload.comment.user.login;
              if (eventName === 'pull_request') return payload.pull_request.user.login;
              return null;
            };

            const isIssueEvent = () => context.eventName === 'issues';
            const isCommentEvent = () => context.eventName === 'issue_comment';
            const isPullEvent = () => context.eventName === 'pull_request';

            const closeIssue = async (issue_number, reasonText) => {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number,
                state: 'closed'
              });
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number,
                body: reasonText
              });
            };

            const closePull = async (pull_number, reasonText) => {
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number,
                state: 'closed'
              });
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pull_number,
                body: reasonText
              });
            };

            const isAuthorizedUser = async (username) => {
              const { data: perm } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username
              });
              return perm.permission === 'admin' || perm.permission === 'write';
            };

            const updateBlocklistVariable = (adminToken, newValue) => {
              const curlCommand = `curl -L -X PATCH \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer ${adminToken}" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                https://api.github.com/repos/${context.repo.owner}/${context.repo.repo}/actions/variables/BLOCKLIST_USERS \
                -d '{"name":"BLOCKLIST_USERS","value":"${newValue}"}'`;
              const { execSync } = require('child_process');
              execSync(curlCommand, { stdio: 'inherit' });
            };

            // Parse `/block [username]`
            const parseBlockTargetFromBody = (body) => {
              const match = body.match(/\/block(?:\s+@?([A-Za-z0-9-]+))?/i);
              return match ? (match[1] || null) : null;
            };

            const eventType = context.eventName;
            const actor = getEventActor();

            const blocklistRaw = process.env.BLOCKLIST_USERS || '${{ vars.BLOCKLIST_USERS }}';
            const prohibitedUsers = (blocklistRaw || '')
              .split(',')
              .map(s => s.trim())
              .filter(Boolean);

            const adminToken = process.env.ADMIN_TOKEN || '${{ secrets.ADMIN_TOKEN }}';

            try {
              // --- Handle /block command ---
              if (isCommentEvent() && /\/block\b/i.test(context.payload.comment.body)) {
                const commenter = actor;
                const authorized = await isAuthorizedUser(commenter);

                if (!authorized) {
                  console.log(`Unauthorized user ${commenter} attempted /block`);
                } else {
                  let userToBlock = parseBlockTargetFromBody(context.payload.comment.body);

                  if (!userToBlock) {
                    // Default to issue/PR opener
                    if (context.payload.issue && context.payload.issue.user) {
                      userToBlock = context.payload.issue.user.login;
                    } else if (context.payload.pull_request && context.payload.pull_request.user) {
                      userToBlock = context.payload.pull_request.user.login;
                    }
                    console.log(`No user specified, defaulting to opener: ${userToBlock}`);
                    // Enforce on current thread
                    if (context.payload.issue && context.payload.issue.pull_request) {
                      // PR comment
                      await closePull(
                        context.payload.issue.number,
                        `This pull request was automatically closed because @${userToBlock} was blocked via /block.`
                      );
                    } else if (context.payload.issue) {
                      // Issue comment
                      await closeIssue(
                        context.payload.issue.number,
                        `This issue was automatically closed because @${userToBlock} was blocked via /block.`
                      );
                    }
                  }

                  if (userToBlock) {
                    if (!prohibitedUsers.includes(userToBlock)) {
                      const updated = blocklistRaw ? `${blocklistRaw},${userToBlock}` : userToBlock;
                      updateBlocklistVariable(adminToken, updated);
                      console.log(`Added ${userToBlock} to BLOCKLIST_USERS`);
                    } else {
                      console.log(`User ${userToBlock} already in BLOCKLIST_USERS`);
                    }

                  } else {
                    console.log("No resolvable user to block.");
                  }
                }
              }

              // --- Automatic enforcement ---
              if (prohibitedUsers.includes(actor)) {
                if (isIssueEvent()) {
                  await closeIssue(
                    context.payload.issue.number,
                    `This issue was automatically closed because it was ${context.payload.action} by a restricted user.`
                  );
                } else if (isCommentEvent()) {
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: context.payload.comment.id
                  });
                } else if (isPullEvent()) {
                  await closePull(
                    context.payload.pull_request.number,
                    `This pull request was automatically closed because it was ${context.payload.action} by a restricted user.`
                  );
                }
              }
            } catch (error) {
              core.setFailed(`Error processing ${eventType}: ${error.message}`);
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ADMIN_TOKEN: ${{ secrets.ADMIN_TOKEN }}
          BLOCKLIST_USERS: ${{ vars.BLOCKLIST_USERS }}
